<!DOCTYPE html>
<html>
<head>
    <title>Lake and Boat Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #fishCaught {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #fishCaught img {
            width: 200px;
            height: 200px;
            margin-bottom: 10px;
        }
        #fishCaught p {
            margin: 10px 0;
            font-size: 18px;
        }
        #collection {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            font-family: Arial, sans-serif;
            width: 80%;
            max-height: 80vh;
            overflow-y: auto;
        }
        #collection h2 {
            text-align: center;
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 24px;
        }
        .fish-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .fish-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        .fish-card img {
            width: 100px;
            height: 100px;
            margin-bottom: 10px;
        }
        .fish-card h3 {
            margin: 5px 0;
            color: #00ffff;
        }
        .fish-card p {
            margin: 5px 0;
            font-size: 14px;
        }
        .record {
            background: rgba(255, 215, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .record h3 {
            color: gold;
            margin: 5px 0;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            z-index: 1000;
        }
        #instructions h3 {
            margin: 0 0 10px 0;
            color: #00ffff;
        }
        #instructions p {
            margin: 5px 0;
            font-size: 14px;
        }
        #instructions .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin-right: 5px;
            font-weight: bold;
        }
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        #joystickArea {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 75px;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        #joystick {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 35px;
            top: 40px;
            left: 40px;
            touch-action: none;
            will-change: transform;
            transform: translate(-50%, -50%);
            -webkit-tap-highlight-color: transparent;
        }
        .mobileButton {
            position: fixed;
            bottom: 30px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 40px;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            transition: transform 0.15s ease-out, background-color 0.15s ease-out;
            -webkit-tap-highlight-color: transparent;
        }
        .mobileButton:active, .mobileButton.mobile-active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.6);
        }
        #fishButton {
            right: 120px;
        }
        #collectionButton {
            right: 30px;
        }
        @media (max-width: 1024px), (pointer: coarse) {
            #mobileControls {
                display: block;
                touch-action: none;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                user-select: none;
            }
            #instructions {
                display: none;
            }
            #fishCaught {
                bottom: 150px;
                top: auto;
                transform: translate(-50%, 0);
            }
        }
        @media (max-width: 768px) {
            #collection {
                padding: 15px;
                width: 90%;
                max-height: 85vh;
            }
            #collection h2 {
                font-size: 20px;
                margin-bottom: 15px;
            }
            .fish-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 10px;
                margin-bottom: 15px;
            }
            .fish-card {
                padding: 10px;
            }
            .fish-card img {
                width: 70px;
                height: 70px;
                margin-bottom: 5px;
            }
            .fish-card h3 {
                font-size: 14px;
                margin: 3px 0;
            }
            .fish-card p {
                font-size: 12px;
                margin: 3px 0;
            }
            .record {
                padding: 10px;
                margin-bottom: 15px;
            }
            .record h3 {
                font-size: 16px;
            }
            .record p {
                font-size: 12px;
                margin: 3px 0;
            }
            .record img {
                width: 60px;
                height: 60px;
            }
            .close-btn {
                font-size: 20px;
                top: 5px;
                right: 5px;
            }
        }
        @media (max-width: 480px) {
            #collection {
                padding: 10px;
                width: 95%;
            }
            .fish-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 8px;
            }
            .fish-card img {
                width: 60px;
                height: 60px;
            }
            .fish-card h3 {
                font-size: 13px;
            }
            .fish-card p {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="fishCaught">
        <img id="fishImage" src="" alt="Caught Fish">
        <p id="fishName"></p>
        <p>Press SPACE to continue fishing</p>
    </div>
    <div id="collection">
        <button class="close-btn">&times;</button>
        <h2>Fish Collection</h2>
        <div class="record">
            <h3>Records</h3>
            <div id="records"></div>
        </div>
        <div class="fish-grid" id="fishGrid"></div>
    </div>
    <div id="instructions">
        <h3>Controls</h3>
        <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> Move boat</p>
        <p><span class="key">SPACE</span> Start/stop fishing</p>
        <p><span class="key">TAB</span> View collection</p>
    </div>
    <div id="mobileControls">
        <div id="joystickArea">
            <div id="joystick"></div>
        </div>
        <button class="mobileButton" id="fishButton">ðŸŽ£</button>
        <button class="mobileButton" id="collectionButton">ðŸ“±</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Mobile device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                          window.innerWidth <= 1024 || 
                          (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
        
        // Show mobile controls if on mobile device
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
            
            // Add viewport meta tag for proper mobile scaling if it doesn't exist
            if (!document.querySelector('meta[name="viewport"]')) {
                const viewport = document.createElement('meta');
                viewport.name = 'viewport';
                viewport.content = 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no';
                document.getElementsByTagName('head')[0].appendChild(viewport);
            }
        }

        // Set up scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add skybox
        const skyboxLoader = new THREE.CubeTextureLoader();
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }), // right - light blue
            new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }), // left - light blue
            new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }), // top - light blue
            new THREE.MeshBasicMaterial({ color: 0x4682B4, side: THREE.BackSide }), // bottom - darker blue
            new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }), // front - light blue
            new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })  // back - light blue
        ];

        const skyboxGeometry = new THREE.BoxGeometry(900, 900, 900);
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);
        
        // Remove the old skybox background
        scene.background = new THREE.Color(0x87CEEB);

        // Add OrbitControls with modified settings
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 50;
        controls.enablePan = false; // Disable panning
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent camera from going below horizon
        controls.minPolarAngle = 0.1; // Prevent camera from going too high
        controls.rotateSpeed = 0.5; // Adjust rotation speed
        
        // Disable OrbitControls on mobile to prevent conflicts with joystick
        if (isMobile) {
            controls.enabled = false;
        }

        // Variables for camera control
        let currentCameraDistance = 25; // Store current zoom level
        let lastBoatPosition = new THREE.Vector3();

        // Add zoom change listener
        controls.addEventListener('change', () => {
            // Update stored camera distance when user zooms
            currentCameraDistance = camera.position.distanceTo(controls.target);
        });

        // Create lake with reflective water
        const lakeGeometry = new THREE.PlaneGeometry(300, 300, 100, 100);
        const waterTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/water.jpg');
        waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
        waterTexture.repeat.set(15, 15);

        // Create normal map for water waves
        const waterNormalMap = new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg');
        waterNormalMap.wrapS = waterNormalMap.wrapT = THREE.RepeatWrapping;
        waterNormalMap.repeat.set(10, 10);
        
        const lakeMaterial = new THREE.MeshPhysicalMaterial({ 
            color: 0x0077be,
            metalness: 0.4,
            roughness: 0.2,
            transmission: 0.3,
            thickness: 0.5,
            envMapIntensity: 1.0,
            clearcoat: 0.6,
            clearcoatRoughness: 0.2,
            normalMap: waterNormalMap,
            normalScale: new THREE.Vector2(0.08, 0.08),
            map: waterTexture,
            transparent: true,
            opacity: 0.92,
        });

        const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
        lake.rotation.x = -Math.PI / 2;
        scene.add(lake);

        // Create environment map for reflections
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter
        });
        const cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);
        scene.add(cubeCamera);
        lakeMaterial.envMap = cubeRenderTarget.texture;

        // Animation function for water
        function animateWater(time) {
            // Animate water texture (slower movement)
            waterTexture.offset.x = time * 0.00002;
            waterTexture.offset.y = time * 0.00001;
            
            // Animate normal map (slower movement)
            waterNormalMap.offset.x = time * 0.00003;
            waterNormalMap.offset.y = time * 0.00002;

            // Update environment map with boat position
            lake.visible = false;
            const boatPos = boat.group.position;
            cubeCamera.position.set(boatPos.x, 0.5, boatPos.z); // Lowered camera height for better reflections
            cubeCamera.update(renderer, scene);
            lake.visible = true;
        }

        // Create islands
        function createIsland(x, z, size, height, complexity) {
            const island = new THREE.Group();
            
            // Create a spherical cap for the island base
            const segments = complexity * 2;
            const baseGeometry = new THREE.SphereGeometry(size, segments, segments / 2, 0, Math.PI * 2, 0, Math.PI / 2);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xC2B280,
                flatShading: false
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Scale the geometry to create the desired height
            base.scale.set(1, height / size, 1);
            
            // Add smooth terrain variation
            const vertices = base.geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const z = vertices[i + 2];
                
                // Calculate distance from center
                const distanceFromCenter = Math.sqrt(x * x + z * z);
                const normalizedDistance = distanceFromCenter / size;
                
                // Add subtle height variation using multiple sine waves
                if (y > 0) {
                    const variation = 
                        Math.sin(normalizedDistance * 5) * 0.1 +
                        Math.sin(normalizedDistance * 8 + x * 0.2) * 0.05 +
                        Math.sin(normalizedDistance * 6 + z * 0.2) * 0.05;
                    
                    vertices[i + 1] += variation;
                }
            }
            base.geometry.attributes.position.needsUpdate = true;
            base.geometry.computeVertexNormals();
            
            // Add vegetation (trees) with better placement
            const treeCount = Math.floor(size * 1.5);
            for (let i = 0; i < treeCount; i++) {
                const treeGeometry = new THREE.ConeGeometry(1.2, 3, 8);  // Doubled size
                const treeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2D5A27,
                    flatShading: false
                });
                const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                
                // Place trees on the curved surface
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * (size * 0.7);
                const treeX = Math.cos(angle) * radius;
                const treeZ = Math.sin(angle) * radius;
                
                // Calculate Y position based on sphere surface
                const normalizedRadius = radius / size;
                const sphereY = Math.sqrt(1 - normalizedRadius * normalizedRadius) * height;
                
                tree.position.set(
                    treeX,
                    sphereY + 1.5,  // Raised position to account for larger size
                    treeZ
                );
                
                // Keep trees upright but slightly tilted based on surface
                const surfaceNormal = new THREE.Vector3(treeX, sphereY, treeZ).normalize();
                const upVector = new THREE.Vector3(0, 1, 0);
                const tiltAmount = 0.2; // Reduced tilt amount
                
                tree.up.copy(upVector);
                tree.up.lerp(surfaceNormal, tiltAmount);
                tree.lookAt(tree.position.clone().add(tree.up));
                
                // Random scale variation (but maintaining larger overall size)
                const scale = 1.2 + Math.random() * 0.4;  // Increased base scale
                tree.scale.set(scale, scale, scale);
                
                // Random rotation around vertical axis only
                tree.rotateOnAxis(new THREE.Vector3(0, 1, 0), Math.random() * Math.PI * 2);
                
                island.add(tree);
            }
            
            island.add(base);
            island.position.set(x, 0, z);
            return island;
        }

        // Add four unique islands with natural archipelago layout
        const islands = [
            // Starting island (close to spawn)
            createIsland(50, 50, 25, 4, 16),    // Moved slightly further out
            
            // Medium island to the east
            createIsland(160, -120, 20, 4, 14),  // Moved further out
            
            // Small island to the north
            createIsland(-100, 160, 15, 3, 12),  // Moved further out
            
            // Large island to the west
            createIsland(-160, -100, 30, 5, 20)  // Moved further out
        ];

        // Create irregular shallow water zones around islands
        function createUnderwaterTerrain(x, z, size) {
            const segments = 64;
            const points = [];
            
            // Create a larger shallow area
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const radius = size * 2.2 * (1 + // Increased from 1.5 to 2.2
                    Math.sin(angle * 2) * 0.15 + 
                    Math.cos(angle * 3) * 0.1 + 
                    Math.sin(angle * 4) * 0.05
                );
                points.push(new THREE.Vector2(Math.cos(angle) * radius, Math.sin(angle) * radius));
            }

            const shapeGeometry = new THREE.ShapeGeometry(new THREE.Shape(points));
            
            // Updated material settings for better transparency handling
            const shallowMaterial = new THREE.MeshPhongMaterial({
                color: 0xADD8E6,  // Light blue color
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                shininess: 100,
                specular: 0x666666,
                depthWrite: false,
                depthTest: true,
                blending: THREE.CustomBlending,
                blendEquation: THREE.AddEquation,
                blendSrc: THREE.SrcAlphaFactor,
                blendDst: THREE.OneMinusSrcAlphaFactor,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -4
            });

            const shallowWater = new THREE.Mesh(shapeGeometry, shallowMaterial);
            shallowWater.rotation.x = -Math.PI / 2;
            shallowWater.position.set(x, 0.3, z);  // Raised higher above the water surface
            shallowWater.renderOrder = 1;  // Ensure it renders after the main water
            
            scene.add(shallowWater);
        }

        // Add underwater terrain around each island
        islands.forEach(island => {
            const pos = island.position;
            createUnderwaterTerrain(pos.x, pos.z, 35);  // Increased size from 25 to 35
            scene.add(island);
        });

        // Add fish types with weight ranges
        const DEEP_WATER_FISH = [
            { 
                name: "Tuna", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_4.png", 
                rarity: 0.3,
                minWeight: 5,
                maxWeight: 30,
                weightScale: 1.8
            },
            { 
                name: "Bass", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_2.png", 
                rarity: 0.25,
                minWeight: 1,
                maxWeight: 12,
                weightScale: 1.8
            },
            { 
                name: "Rainbow Trout", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_3.png", 
                rarity: 0.2,
                minWeight: 0.5,
                maxWeight: 8,
                weightScale: 2.0
            },
            { 
                name: "Legendary Fish", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_6.png", 
                rarity: 0.05,
                minWeight: 10,
                maxWeight: 50,
                weightScale: 2.2
            }
        ];

        const SHALLOW_WATER_FISH = [
            { 
                name: "Small Carp", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_1.png", 
                rarity: 0.35,
                minWeight: 0.5,
                maxWeight: 5,
                weightScale: 1.5
            },
            { 
                name: "Tropical Fish", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_5.png", 
                rarity: 0.25,
                minWeight: 0.2,
                maxWeight: 2,
                weightScale: 1.8
            },
            { 
                name: "Angelfish", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_3.png", 
                rarity: 0.2,
                minWeight: 0.1,
                maxWeight: 1,
                weightScale: 1.5
            },
            { 
                name: "Coral Fish", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_2.png", 
                rarity: 0.15,
                minWeight: 0.3,
                maxWeight: 3,
                weightScale: 1.8
            },
            { 
                name: "Golden Minnow", 
                image: "https://raw.githubusercontent.com/Aceship/Arknight-Images/main/avg/items/item_fish_6.png", 
                rarity: 0.05,
                minWeight: 0.1,
                maxWeight: 0.5,
                weightScale: 2.0
            }
        ];

        // Function to check if a point is in shallow water
        function isInShallowWater(x, z) {
            for (const island of islands) {
                const dx = x - island.position.x;
                const dz = z - island.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const shallowRadius = island.scale.x * 35 * 2.2; // Match the shallow water size calculation
                if (distance <= shallowRadius) {
                    return true;
                }
            }
            return false;
        }

        // Add weight generation function
        function generateFishWeight(minWeight, maxWeight, scale) {
            // Generate a random number between 0 and 1
            const rand = Math.random();
            
            // Use exponential distribution to bias towards smaller weights
            // Math.pow(rand, scale) gives us more small numbers as scale increases
            const weight = minWeight + (maxWeight - minWeight) * Math.pow(rand, scale);
            
            // Round to 1 decimal place
            return Math.round(weight * 10) / 10;
        }

        // Create boat class
        class Boat {
            constructor() {
                this.group = new THREE.Group();
                this.speed = 0.2;
                this.rotationSpeed = 0.03;
                this.isFishing = false;
                this.fishingLine = null;
                this.fishingRadius = null;
                this.fishingStartTime = 0;
                this.canCatchFish = false;
                this.collection = {};  // Store caught fish
                this.records = {};     // Store records
                this.collisionRadius = 2; // Radius for boat collision
                this.createBoat();
            }

            createBoat() {
        // Boat hull
                const hullGeometry = new THREE.BoxGeometry(2.5, 1.5, 5);
                const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x800000 });
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                this.group.add(hull);

                // Boat cabin
                const cabinGeometry = new THREE.BoxGeometry(2, 1.5, 2);
                const cabinMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
                cabin.position.set(0, 1.25, -0.5);
                this.group.add(cabin);

                // Cabin roof
                const roofGeometry = new THREE.BoxGeometry(2.2, 0.2, 2.2);
                const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 2.1, -0.5);
                this.group.add(roof);

                // Fishing rod holders
                const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(0.5, 1.5, 1.5);
                pole.rotation.z = -Math.PI / 6;
                this.group.add(pole);

                const pole2 = pole.clone();
                pole2.position.set(-0.5, 1.5, 1.5);
                pole2.rotation.z = Math.PI / 6;
                this.group.add(pole2);

                // Front railing
                const railingGeometry = new THREE.TorusGeometry(1, 0.03, 8, 12, Math.PI);
                const railingMaterial = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
                const railing = new THREE.Mesh(railingGeometry, railingMaterial);
                railing.position.set(0, 1.2, 2);
                railing.rotation.y = Math.PI / 2;
                this.group.add(railing);

                // Create fishing line (initially hidden)
                const lineGeometry = new THREE.BufferGeometry();
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFFFFF });
                const linePoints = new Float32Array([
                    0, 1.5, 1.5,  // Start point (at the rod tip)
                    0, 0, 1.5     // End point (in water)
                ]);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePoints, 3));
                this.fishingLine = new THREE.Line(lineGeometry, lineMaterial);
                this.fishingLine.visible = false;
                this.group.add(this.fishingLine);

                // Create fishing radius indicator (initially hidden)
                const radiusGeometry = new THREE.RingGeometry(3, 3.2, 32);
                const radiusMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                this.fishingRadius = new THREE.Mesh(radiusGeometry, radiusMaterial);
                this.fishingRadius.rotation.x = -Math.PI / 2; // Lay flat on water
                this.fishingRadius.position.y = 0.1; // Slightly above water
                this.fishingRadius.visible = false;
                this.group.add(this.fishingRadius);

                // Create glow effect for the radius
                const glowGeometry = new THREE.RingGeometry(2.8, 3.4, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                this.glowRadius = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glowRadius.rotation.x = -Math.PI / 2;
                this.glowRadius.position.y = 0.1;
                this.glowRadius.visible = false;
                this.group.add(this.glowRadius);

                this.group.position.y = 1;
                this.group.rotation.y = -Math.PI / 2;
            }

            checkCollision(newPosition) {
                // Check collision with each island
                for (const island of islands) {
                    const dx = newPosition.x - island.position.x;
                    const dz = newPosition.z - island.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    // Get the island's size (assuming it's the first child's scale)
                    const islandBase = island.children[island.children.length - 1];
                    const islandRadius = islandBase.geometry.parameters.radius * islandBase.scale.x;
                    
                    // Add some padding to the collision radius
                    const minDistance = islandRadius + this.collisionRadius;
                    
                    if (distance < minDistance) {
                        return true; // Collision detected
                    }
                }
                return false; // No collision
            }

            moveForward() {
                if (!this.isFishing) {
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.group.quaternion);
                    
                    // Calculate new position
                    const newPosition = this.group.position.clone().add(direction.multiplyScalar(this.speed));
                    
                    // Only move if there's no collision
                    if (!this.checkCollision(newPosition)) {
                        this.group.position.copy(newPosition);
                    }
                }
            }

            moveBackward() {
                if (!this.isFishing) {
                    const direction = new THREE.Vector3(0, 0, 1);
                    direction.applyQuaternion(this.group.quaternion);
                    
                    // Calculate new position
                    const newPosition = this.group.position.clone().add(direction.multiplyScalar(this.speed));
                    
                    // Only move if there's no collision
                    if (!this.checkCollision(newPosition)) {
                        this.group.position.copy(newPosition);
                    }
                }
            }

            turnLeft() {
                if (!this.isFishing) {
                    this.group.rotation.y += this.rotationSpeed;
                }
            }

            turnRight() {
                if (!this.isFishing) {
                    this.group.rotation.y -= this.rotationSpeed;
                }
            }

            toggleFishing() {
                this.isFishing = !this.isFishing;
                this.fishingLine.visible = this.isFishing;
                this.fishingRadius.visible = this.isFishing;
                this.glowRadius.visible = this.isFishing;
                
                if (this.isFishing) {
                    this.fishingStartTime = Date.now();
                    this.canCatchFish = false;
                    // Increased initial waiting time to 5 seconds
                    setTimeout(() => {
                        this.canCatchFish = true;
                    }, 5000);

                    const linePositions = this.fishingLine.geometry.attributes.position.array;
                    linePositions[4] = 0;
                    this.fishingLine.geometry.attributes.position.needsUpdate = true;
                } else {
                    document.getElementById('fishCaught').style.display = 'none';
                }
            }

            checkForFish() {
                if (!this.canCatchFish || !this.isFishing) return;

                const timeSpentFishing = (Date.now() - this.fishingStartTime) / 1000; // Convert to seconds
                const baseProbability = 0.02; // 2% base chance per check (reduced from 10%)
                const timeBonus = Math.min(0.08, timeSpentFishing * 0.002); // Max 8% bonus, slower increase
                const catchChance = baseProbability + timeBonus;

                if (Math.random() < catchChance) {
                    this.catchFish();
                }
            }

            catchFish() {
                // Determine which fish list to use based on location
                const isShallow = isInShallowWater(this.group.position.x, this.group.position.z);
                const availableFish = isShallow ? SHALLOW_WATER_FISH : DEEP_WATER_FISH;
                
                // Generate a random number between 0 and 1
                const rand = Math.random();
                
                // Calculate total probability to normalize
                const totalProbability = availableFish.reduce((sum, fish) => sum + fish.rarity, 0);
                let cumulativeProbability = 0;
                let caughtFish = null;

                // Normalize probabilities and select fish
                for (const fish of availableFish) {
                    cumulativeProbability += fish.rarity / totalProbability;
                    if (rand <= cumulativeProbability && !caughtFish) {
                        caughtFish = fish;
                    }
                }

                // Fallback to first fish if somehow none was selected
                if (!caughtFish) {
                    caughtFish = availableFish[0];
                }

                const weight = generateFishWeight(
                    caughtFish.minWeight,
                    caughtFish.maxWeight,
                    caughtFish.weightScale
                );

                // Update collection with water type tracking
                const collectionKey = `${caughtFish.name}_${isShallow ? 'shallow' : 'deep'}`;
                if (!this.collection[collectionKey]) {
                    this.collection[collectionKey] = {
                        name: caughtFish.name,
                        count: 0,
                        heaviest: 0,
                        image: caughtFish.image,
                        isShallow: isShallow
                    };
                }
                this.collection[collectionKey].count++;
                this.collection[collectionKey].heaviest = Math.max(
                    this.collection[collectionKey].heaviest,
                    weight
                );

                // Update records
                if (!this.records.heaviest || weight > this.records.heaviest.weight) {
                    this.records.heaviest = {
                        name: caughtFish.name,
                        weight: weight,
                        image: caughtFish.image,
                        isShallow: isShallow
                    };
                }

                // Display the caught fish
                const fishCaughtDiv = document.getElementById('fishCaught');
                const fishImage = document.getElementById('fishImage');
                const fishName = document.getElementById('fishName');

                fishImage.src = caughtFish.image;
                fishName.textContent = `You caught a ${caughtFish.name}!\nWeight: ${weight} lbs${isShallow ? '\n(Shallow Water Catch!)' : ''}`;
                fishCaughtDiv.style.display = 'block';

                this.canCatchFish = false;
            }

            showCollection() {
                const collection = document.getElementById('collection');
                const fishGrid = document.getElementById('fishGrid');
                const records = document.getElementById('records');
                
                // Clear previous content
                fishGrid.innerHTML = '';
                records.innerHTML = '';

                // Add records
                if (this.records.heaviest) {
                    records.innerHTML = `
                        <p>Heaviest Fish: ${this.records.heaviest.name} (${this.records.heaviest.weight} lbs)</p>
                        <p>${this.records.heaviest.isShallow ? 'Caught in Shallow Water' : 'Caught in Deep Water'}</p>
                        <img src="${this.records.heaviest.image}" style="width: 100px; height: 100px;">
                    `;
                }

                // Create sections for shallow and deep water catches
                const shallowSection = document.createElement('div');
                shallowSection.innerHTML = '<h2 style="color: #00ffff; margin-top: 20px;">Shallow Water Catches</h2>';
                const shallowGrid = document.createElement('div');
                shallowGrid.className = 'fish-grid';
                shallowSection.appendChild(shallowGrid);

                const deepSection = document.createElement('div');
                deepSection.innerHTML = '<h2 style="color: #0077be; margin-top: 20px;">Deep Water Catches</h2>';
                const deepGrid = document.createElement('div');
                deepGrid.className = 'fish-grid';
                deepSection.appendChild(deepGrid);

                // Sort and add all caught fish
                for (const [key, data] of Object.entries(this.collection)) {
                    const card = document.createElement('div');
                    card.className = 'fish-card';
                    card.innerHTML = `
                        <img src="${data.image}" alt="${data.name}">
                        <h3>${data.name}</h3>
                        <p>Caught: ${data.count}</p>
                        <p>Heaviest: ${data.heaviest} lbs</p>
                    `;
                    
                    if (data.isShallow) {
                        shallowGrid.appendChild(card);
                    } else {
                        deepGrid.appendChild(card);
                    }
                }

                // Add sections to the grid
                fishGrid.appendChild(deepSection);
                fishGrid.appendChild(shallowSection);

                collection.style.display = 'block';
            }

            update(time) {
                // Bob up and down
                this.group.position.y = 1 + Math.sin(time) * 0.2;

                // Animate fishing line and check for fish
                if (this.isFishing) {
                    const linePositions = this.fishingLine.geometry.attributes.position.array;
                    linePositions[4] = 0.2 + Math.sin(time * 2) * 0.1;
                    this.fishingLine.geometry.attributes.position.needsUpdate = true;

                    this.glowRadius.material.opacity = 0.2 + Math.sin(time * 3) * 0.1;
                    this.fishingRadius.material.opacity = 0.5 + Math.sin(time * 3) * 0.2;

                    // Check for fish every update
                    this.checkForFish();
                }
            }
        }

        // Create boat instance
        const boat = new Boat();
        scene.add(boat.group);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // Add fog for softer atmosphere
        scene.fog = new THREE.Fog(0x87CEEB, 80, 300);

        // Position camera
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        // Update key controls
        const keys = {
            w: false,
            s: false,
            a: false,
            d: false,
            space: false
        };

        // Update keyboard controls
        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 's': keys.s = true; break;
                case 'a': keys.a = true; break;
                case 'd': keys.d = true; break;
                case ' ': 
                    if (!keys.space) {
                        boat.toggleFishing();
                    }
                    keys.space = true;
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 's': keys.s = false; break;
                case 'a': keys.a = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
            }
        });

        // Animation variables
        let time = 0;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Handle boat movement
            if (keys.w) {
                boat.moveForward();
            }
            if (keys.s) {
                boat.moveBackward();
            }
            if (keys.a) {
                boat.turnLeft();
            }
            if (keys.d) {
                boat.turnRight();
            }

            // Update boat and water
            time += 0.01;
            boat.update(time);
            animateWater(time * 1000);

            // Update camera position while maintaining zoom level
            const boatPosition = boat.group.position.clone();
            
            // Only update camera if boat has moved
            if (!boatPosition.equals(lastBoatPosition)) {
                controls.target.copy(boatPosition);
                
                // Get current camera direction relative to boat
                const directionToCamera = camera.position.clone().sub(controls.target).normalize();
                
                // Set camera position at the desired distance
                camera.position.copy(boatPosition.clone().add(directionToCamera.multiplyScalar(currentCameraDistance)));
                
                lastBoatPosition.copy(boatPosition);
            }
            
            // Apply damping to camera movement
            controls.update();

            renderer.render(scene, camera);
        }

        // Handle window resizing
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate();

        // Add event listeners for collection UI
        document.querySelector('.close-btn').addEventListener('click', () => {
            document.getElementById('collection').style.display = 'none';
        });

        // Function to toggle collection visibility
        function toggleCollection() {
            const collection = document.getElementById('collection');
            if (collection.style.display === 'block') {
                collection.style.display = 'none';
            } else {
                boat.showCollection();
            }
        }

        // Add Tab key handler for toggling collection
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                e.preventDefault(); // Prevent tab from changing focus
                toggleCollection();
            }
        });

        // Add mobile touch controls
        let joystickActive = false;
        let joystickStartPos = { x: 0, y: 0 };
        let joystickCenter = { x: 0, y: 0 };
        const joystickArea = document.getElementById('joystickArea');
        const joystick = document.getElementById('joystick');
        const fishButton = document.getElementById('fishButton');
        const collectionButton = document.getElementById('collectionButton');

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            const rect = joystickArea.getBoundingClientRect();
            
            // Store the joystick's center position
            joystickCenter.x = rect.left + rect.width / 2;
            joystickCenter.y = rect.top + rect.height / 2;
            
            // Store the initial touch position
            joystickStartPos.x = touch.clientX;
            joystickStartPos.y = touch.clientY;
            
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function handleJoystickEnd(e) {
            joystickActive = false;
            // Reset joystick position with transition
            joystick.style.transition = 'transform 0.15s ease-out';
            joystick.style.transform = 'translate(-50%, -50%)';
            // Reset movement keys
            keys.w = keys.s = keys.a = keys.d = false;
            
            // Clear transition after it completes
            setTimeout(() => {
                joystick.style.transition = '';
            }, 150);
        }

        function updateJoystickPosition(x, y) {
            const dx = x - joystickCenter.x;
            const dy = y - joystickCenter.y;
            const maxDistance = 50; // Maximum joystick movement radius
            
            // Calculate distance from center
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize the distance
            const normalizedDistance = Math.min(distance, maxDistance);
            const angle = Math.atan2(dy, dx);
            
            // Calculate final joystick position
            const joystickX = Math.cos(angle) * normalizedDistance;
            const joystickY = Math.sin(angle) * normalizedDistance;
            
            // Remove transition during active movement
            joystick.style.transition = '';
            joystick.style.transform = `translate(calc(${joystickX}px - 50%), calc(${joystickY}px - 50%))`;
            
            // Calculate movement intensity (0 to 1)
            const intensity = Math.min(distance / maxDistance, 1);
            
            // Update movement keys with analog control
            const deadzone = 0.2; // Minimum movement threshold
            if (intensity > deadzone) {
                const forward = -Math.cos(angle - Math.PI/2); // Convert to forward direction
                const right = Math.sin(angle - Math.PI/2);   // Convert to right direction
                
                keys.w = forward > deadzone;
                keys.s = forward < -deadzone;
                keys.a = right < -deadzone;
                keys.d = right > deadzone;
            } else {
                keys.w = keys.s = keys.a = keys.d = false;
            }
        }

        // Initialize mobile controls
        if (isMobile) {
            console.log("Mobile device detected, initializing mobile controls");
            
            // Add touch event listeners for joystick with proper cleanup
            const addJoystickListeners = () => {
                joystickArea.addEventListener('touchstart', handleJoystickStart, { passive: false });
                document.addEventListener('touchmove', handleJoystickMove, { passive: false });
                document.addEventListener('touchend', handleJoystickEnd);
                document.addEventListener('touchcancel', handleJoystickEnd);
            };
            
            // Initial setup
            addJoystickListeners();
            
            // Handle button touches with improved feedback
            function handleButtonTouch(button, action) {
                let isActive = false;
                
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!isActive) {
                        isActive = true;
                        button.classList.add('mobile-active');
                        action();
                    }
                }, { passive: false });

                button.addEventListener('touchend', () => {
                    isActive = false;
                    button.classList.remove('mobile-active');
                });

                button.addEventListener('touchcancel', () => {
                    isActive = false;
                    button.classList.remove('mobile-active');
                });
            }

            handleButtonTouch(fishButton, () => boat.toggleFishing());
            handleButtonTouch(collectionButton, toggleCollection);
            
            // Update fishing popup text for mobile
            const fishingText = document.querySelector('#fishCaught p:last-child');
            fishingText.textContent = 'Tap fishing button to continue';
        }

        // Prevent default touch behavior only on game controls
        document.addEventListener('touchmove', (e) => {
            if (e.target.closest('#joystickArea, .mobileButton, #collection, #fishCaught')) {
                e.preventDefault();
            }
        }, { passive: false });

        animate();
    </script>
</body>
</html>

